---
25layout:     post
title:      组合数学与算法题-欧几里得算法与扩展的欧几里得
subtitle:   欧几里得算法
date:       2019-01-20
author:     rosewind
header-img: img/animation/643.jpg
catalog: true
tags:
    - leetcode
    - 算法
---

# 前言

这一篇讲下欧几里得算法与扩展的欧几里得算法。用欧几里得算法求最大公约数，用扩展的欧几里得算法求乘法逆元。

#  欧几里得算法

相信学程序的都会遇到这个题:求最大公约数与最大公倍数。这里我们换个角度来理解。

## 换个角度理解最大公因数与最小公倍数

我们从质因数分解的角度来理解。质因数分解具有唯一性(这也是1不是质数的原因),

一些例子:

$$
15 = 3 \times 5
$$

$$
25 = 5 \times 5
$$

$$
144 = 2^4 \times 3^2
$$



## 最大公因数

最大公因数即2个数质因数分解后，最大的重叠部分

例:

- 15与25,可以看成{3,5}与{5,5}求重叠的部分，重叠部分即1个5，故最大公因数也为5

- 15与144,可以看成{3,5}与{2,2,2,2,3,3}求重叠部分，最大重叠部分是1个3，故最大公因数为3

这样也不难理解，若2个数互质，最大公因数为1，因为没有重叠的质因子

## 最小公倍数

最小公倍数,即最小的一个数，要覆盖2个数里所有的质因子

- 15与25的最小公倍数,{3,5}与{5,5}则要取成{3,5,5}，即75

- 15与144的最小公倍数，则要取{2,2,2,2,3,3,5}，即720

根据这一规则，很容易理解，若2个数互质，则最小公倍数即2数乘积

## 2者关系

可用2者乘积除以最大公约数，得到的即为最大公约数

思考一下:这样做恰好去除了最大公因数中的因子，即重叠部分

以15,25为例，相乘得到{3,5,5,5}，去掉最大公因数{5},去掉了重叠部分，保证了这个公倍数是最小的

## 欧几里得算法

$$
gcd(a,b) = gcd(b,a \mod b)
$$

见的很多了，用递归或者循环实现均可

为什么这样做就是对的呢?

我们先来看下面一个结论
$$
若a>b,gcd(a,b)=gcd(a-b,b)
$$

还是以a=25,b=15为例,
$$
a-b=5 \times 5 - 3\times5=5\times(5-3)=5\times2
$$

$$
b=3\times5
$$

我们发现，**a-b提取公因式的过程，正是保留公共因子,去掉多余因子的过程**

**用这一规则，不断相减，多余的因子一定会被去掉，剩下的即所求的最大公因数**

不断相减，其实与取余是一样的

# 扩展的欧几里得算法

详细介绍见[扩展的欧几里得算法](https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)

先做个简单的推导,将欧几里得算法与扩展的算法写在一起
$$
gcd(a,b)=ax+by
$$

$$
gcd(b,a\%b)=bx^{'}+(a\%b)y^{'}
$$

两者是相等的注意到$a\%b=a-\lfloor \frac{a}{b} \rfloor\times b​$,所以可以写成
$$
ax+by=ay^{'}+b(x^{'}-\lfloor \frac{a}{b} \rfloor y^{'})
$$
比较之后，就得到了**关键的公式**
$$
x=y^{'},y=x^{'}-\lfloor \frac{a}{b} \rfloor y^{'}
$$

## 为什么能求乘法逆元

为什么这样能求模n下的乘法逆元，**若a,n互质**,则
$$
gcd(a,n)=ax+ny=1
$$
两边同时mod n可以得到:
$$
ax\mod n=1
$$
**这正是乘法逆元的定义，x即a在n下的乘法逆元**

**至于如何求这个数,可以借用上面推出来的关键的公式**

## 例子

求5在11下的乘法逆元

- 从上到下，正常的求最大公因数

  |  a   |  b   |  x   |  y   |
  | :--: | :--: | :--: | :--: |
  |  5   |  11  |      |      |
  |  11  |  5   |      |      |
  |  5   |  1   |      |      |
  |  1   |  0   |  1   |  0   |

  **最大公约数为1，说明存在乘法逆元**

- 接下来，从下往上，用上面的公式向上更新x，y

  | a    | b    | x    | y        |
  | ---- | ---- | ---- | -------- |
  | 5    | 11   | -2   |          |
  | 11   | 5    | 1    | 0-2*1=-2 |
  | 5    | 1    | 0    | 1-0=0    |
  | 1    | 0    | 1    | 0        |

**-2即为所求，在mod 11下即为9,5*9 mod 11 =1,确实是乘法逆元**

## 程序实现

**先从上到下，再从下到上，就是一个递归的过程，关键代码如下**

**程序来源**:

作者：好啊
链接：[关于扩展欧几里得算法？](https://www.zhihu.com/question/30067108/answer/153440477)
来源：知乎

```c
void exgcd(int a, int b, int &d, int &x ,int  &y)
{
	if ( !b )
	{
        d = a;
		x = 1;
		y = 0;
		return;
	}
	int x1,y1;
	exgcd( b , a % b , d , x1 , y1 );
	x = y1;
	y = x1 - ( a / b ) * y1;
	return ;
}

```

**可以通过在传参的时候改变位置，简化代码**

```c
void exgcd(int a, int b, int &d, int &x,int &y)
{
	if(!b)
	{   
        d = a;
		x = 1;
		y = 0;
		return;
	}
	exgcd(b , a%b , d , y , x);
	y-=a/b*x;
}
```

