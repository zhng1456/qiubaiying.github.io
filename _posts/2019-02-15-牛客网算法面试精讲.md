---
layout:     post
title:      牛客网算法面试精讲
subtitle:   算法
date:       2019-02-15
author:     rosewind
header-img: img/animation/3.jpg
catalog: true
tags:
    - 算法
    - leetcode
---

# 前言

为了给了自己点复习压力，买了牛客的算法课程。里面的练习没有覆盖课程中所有的题目，故开个帖子，也算是监督自己吧，做个总结归纳。题目都是比较基础的题目。

# 二叉树

## 层序遍历

[二叉树的层序遍历](https://leetcode-cn.com/explore/featured/card/top-interview-questions-easy/7/trees/50/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        //最基本的层序遍历
        //用来熟悉一下java中的队列
        List<List<Integer>> res=new ArrayList<List<Integer>>();
        if(root==null) return res;
        Queue<TreeNode> q=new LinkedList<TreeNode>();
        q.add(root);
        //终止条件是队列非空
        while(!q.isEmpty()){
            //此时队列中的元素个数即这一层的元素个数
            //后面的操作会改变长度，故先用变量保存
            int oneSize=q.size();
            List<Integer> oneLevel=new ArrayList<Integer>();
            for(int i=0;i<oneSize;i++){
                TreeNode current=q.poll();
                oneLevel.add(current.val);
                if(current.left!=null) q.add(current.left);
                if(current.right!=null) q.add(current.right);
            }
            //将一层的结果添加进入res
            res.add(oneLevel);
        }
        return res;
    }
}
```

## 序列化

[二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

这里使用的是层序遍历的方式

**注意序列化的时候要保留null，转化为#,为null的节点也要入队**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {
    //我这里使用层序遍历的思路
    //序列化为1!2!3!#!#!4!5!
    private String bfs(TreeNode root){
        if(root == null) return null;
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        q.offer(root);
        StringBuilder sb = new StringBuilder();
        while(!q.isEmpty()){
            TreeNode current = q.poll();
            String tmp = current == null? "#" : current.val + "";
            sb.append(tmp + "!");
            //null要转化为#,所以不能这样写
            /*if(current.left != null) q.offer(current.left);
            if(current.right != null) q.offer(current.right);*/
            if(current != null){
                q.offer(current.left);
                q.offer(current.right);
            }
        }
        return sb.toString();
    }
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        return bfs(root);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        //根据1!2!3!#!#!4!5!构建二叉树
        if(data == null || data.equals("")) return null;
        String[] info = data.split("!");
        //建立TreeNode数组
        TreeNode[] nodes = new TreeNode[info.length];
        for(int i = 0; i < info.length;i++){
            if(!info[i].equals("#")) nodes[i] = new TreeNode(Integer.parseInt(info[i])); 
        }
        //开始构建树
        //i,j相当于2个指针
        int j = 1;
        for(int i = 0; j < nodes.length; i++){
            if(nodes[i] != null){
                nodes[i].left = nodes[j++];
                nodes[i].right = nodes[j++];
            }
        }
        return nodes[0];
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```



# 字符串

## 逆序

[反转字符串](https://leetcode-cn.com/explore/featured/card/top-interview-questions-easy/5/strings/32/)

```java
class Solution {
    public String reverseString(String s) {
        //转换为数组处理
        char[] res=s.toCharArray();
        int n=res.length;
        for(int i=0,j=n-1;i<j;i++,j--){
            //交换
            char tmp=res[i];
            res[i]=res[j];
            res[j]=tmp;
        }
        return new String(res);
    }
}
```

## 翻转字符串中的单词

[翻转字符串中的单词](https://www.lintcode.com/problem/reverse-words-in-a-string/description)

## 拼接字典序最小的字符串

# 排序专题

## 冒泡排序

```java
import java.util.*;

public class BubbleSort {
    public int[] bubbleSort(int[] A, int n) {
        // write code here
        //冒泡排序
        for(int i = 0; i < n - 1; i++){
            for(int j = 0;j < n - i - 1; j++){
                if(A[j] > A[j+1]){
                    //交换
                    int tmp = A[j];
                    A[j] = A[j+1];
                    A[j+1] = tmp;
                }
            }
        }
        return A;
    }
}
```

