---
layout:     post
title:     编程题模板
subtitle:   leetcode
date:       2019-09-08
author:     rosewind
header-img: img/animation/41.jpg
catalog: true
tags:
    - leetcode
---

# 前言

常见的模板

## 逻辑类

### 求最小公倍数gcd

```java
public long gcd(long a,long b){
    if(b == 0) return a;
    return gcd(b,a%b);
}
```

### 容斥定理

```
A∪B∪C = A+B+C - A∩B - B∩C - C∩A + A∩B∩C
```

- 2019年9月22日，周赛155场，求第n个丑数(质因数只包含2,3,5的正整数),今天的题目是丑数是可以被 `a` **或** `b` **或** `c` 整除的 **正整数**，求第n个，并且长度限制了无法遍历，可以用容斥定理，二分来求

[丑数 III](https://leetcode-cn.com/contest/weekly-contest-155/problems/ugly-number-iii/)

### 搜索类相关

##### DFS

常见的有二叉树的递归遍历，找联通块的数量等，这里联通的定义需要根据题目做出变化

[岛屿的数量](https://leetcode-cn.com/problems/number-of-islands/submissions/)

```java
class Solution {
    public int numIslands(char[][] grid) {
        //典型的dfs
        int res = 0;
        for(int i = 0; i < grid.length;i++){
            for(int j = 0;j < grid[0].length;j++){
                if(grid[i][j] == '0') continue;;
                dfs(grid,i,j);
                res++;
            }
        }
        return res;
    }
    
    public void dfs(char[][] grid,int i,int j){
        int m = grid.length;
        int n = grid[0].length;
        if(i < 0 || j < 0 || i >= m || j >= n) return;
        if(grid[i][j] == '0') return;
        grid[i][j] = '0';//将1置为0，表示已经访问过
        //递归
        dfs(grid,i + 1,j);
        dfs(grid,i,j + 1);
        dfs(grid,i,j - 1);
        dfs(grid,i - 1,j);
    }
}
```

##### DFS的模板

```java
public void dfs(.....){
    	//边界条件，往往是判断坐标，值是不是我们想要的值,是否已经访问过
        if(边界条件) return;
    	if(边界条件) return;
    	//合法的输入,这里根据题目要求，可以存入list，计数等等
    	do something
    	标记为已访问	//重要!
        //递归,朝哪些方向递归也需要根据题目
    	dfs(....)
        dfs(....)
    }
```



##### BFS

[以二叉树层序遍历为例](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

//这里用q.size()获取当前层的节点数，这样每一层大循环就是一层

//不需要标识层的话，去掉内层循环的for也可，因为外层是while(!q.isEmpty())

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        if(root != null) q.add(root);
        while(!q.isEmpty()){
            int size = q.size();
            List<Integer> level = new ArrayList<Integer>();
            for(int i = 0;i < size;i++){
                TreeNode cur = q.poll();
                level.add(cur.val);
                if(cur.left != null) q.add(cur.left);
                if(cur.right != null) q.add(cur.right);
            }
            res.add(level);
        }
        return res;
    }
}
```

[用bfs在地图中寻路](https://leetcode-cn.com/contest/biweekly-contest-9/problems/minimum-knight-moves/)

加入可行方向，并记录距离即可

**不同的题目，方向不同，可达节点判断不同即可**

```java
class Solution {
    public int minKnightMoves(int x, int y) {
        if(x == 0 && y == 0){
			return 0;
		}
		boolean [][]visited = new boolean[700][700];
		int [][]dire = {{1,-2},{1,2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}};
		Queue<int[]> queue = new LinkedList<int[]>();
		visited[300][300] = true;
		queue.offer(new int[]{300,300});
		int result = 1;
		while (!queue.isEmpty()) {
			int size = queue.size();
			for (int i = 0; i < size; i++) {
				int []tem = queue.poll();
				for (int j = 0; j < dire.length; j++) {
					int temx = tem[0] + dire[j][0];
					int temy = tem[1] + dire[j][1];
					if(temx - 300 == x && temy - 300 == y){
						return result;
					}
					if(!visited[temx][temy]){
						visited[temx][temy] = true;
						queue.offer(new int[]{temx,temy});
					}
				}
			}
			result ++;
		}
		return result;
    }
}
```

##### BFS的模板

```java
public void bfs(Node node){
    Queue<Node> q = new LinkedList<Node>();
    q.add(node);
    while(!q.isEmpty()){
        Node cur = q.poll();
        do something,获取所有可达node
        for(Node newNode:nodes){
            if(一些条件) q.add(newNode);
        }
    }
}


//需要记录距离，或者按层时，加一个size
//可以加入visited数组避免重复访问
public void bfs(Node node){
    Queue<Node> q = new LinkedList<Node>();
    q.add(node);
    while(!q.isEmpty()){
        int size = q.size();
        for(int i = 0;i < size;i++){
              Node cur = q.poll();
              do something,获取所有可达node
              for(Node newNode:nodes){
                  if(一些条件) q.add(newNode);
              }
        }
    }
}
```

### 年月日求星期

```java
class Solution {
    public String dayOfTheWeek(int day, int month, int year) {
        //参考蔡勒公式
        String[] res = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
        if(month < 3){
            year--;
            month += 12;
        }
        int c = year/100;
        int y = year - c*100;
        int week = y + y / 4 + c / 4 - 2 * c + 26 * (month + 1) / 10 + day - 1;
        week = (week%7 + 7) % 7;
        return res[week];
    }
}
```

