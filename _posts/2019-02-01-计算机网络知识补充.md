---
25layout:     post
title:      计算机网络知识补充
subtitle:   TCP,UDP
date:       2019-02-01
author:     rosewind
header-img: img/animation/10.jpg
catalog: true
tags:
    - java
---

# 概述

之前转载了一篇计算机网络的知识点，里面有几个重点讲的不够清楚，这里做一个补充。

# TCP三次握手

## 流程

![](https://images.cnblogs.com/cnblogs_com/wupeixuan/1185085/o_2964446-aa923712d5218eeb.png)

1. 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
2. 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
3. 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

## 为什么需要3次，而不是2次？

**防止两次握手情况下已失效的连接请求报文段突然又传送到服务端,而产生的错误。**

举一个例子分析，为什么不是2次握手:

1. Client向Server发出TCP连接请求，第一个连接请求在网络的某个节点长时间滞留，Client超时后认为报文丢失。于是再重传一次，Server收到后建立连接，传输完毕后双方断开连接。
2. 前一个滞留在网络中的请求到达Server,这时Server认为Client又发来了连接请求。

**若使用的2次握手**，则Server认为连接已经建立，等待Client发送数据，但此时Client并无数据发送，造成了Server的资源白白浪费了。

**若使用的是3次握手**，则Server向Client返回确认报文段,由于是一个失效的请求,因此Client不予理睬,建立连接失败。

**第三次握手的作用:防止已失效的连接请求报文段突然又传送到了服务器。**

注:[TCP 为什么是三次握手，而不是两次或四次？作者：胡永浩](https://www.zhihu.com/question/24853633/answer/573627478)文中写的很好，因为没有网络全局时钟，两台机器分别为了确认序号，证明这个包是新的，而不是在链路中delay的，TCP 的可靠连接是靠 seq（ sequence numbers 序列号）来达成的。

> 如果你细读[RFC793](https://link.zhihu.com/?target=https%3A//www.ietf.org/rfc/rfc793.txt)，也就是 TCP 的协议 RFC，你就会发现里面就讲到了为什么三次握手是必须的——TCP 需要 seq 序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq，因此需要三次握手来约定确定双方的 ISN（初始 seq 序列号）。
>

# 四次挥手(Client或Server均可主动发起挥手动作)

![](https://images.cnblogs.com/cnblogs_com/wupeixuan/1185085/o_2964446-2b9562b3a8b72fb2.png)

1. 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
2. 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
3. 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
4. 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

## 为什么连接的时候是三次握手，关闭的时候却是四次握手？

Server在LISTEN状态下，收到建立连接请求的SYN报文后，可以直接把ACK和SYN放在一个报文里发送给Client。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

## 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

1. Client的最后一个ACK报文在传输的时候丢失，Server并没有接收到这个报文。这个时候，Server就会超时重传这个FIN消息，然后Client就会重新返回最后一个ACK报文，等待两个时间周期，完成关闭。如果不等待这两个时间周期，Server重传的那条消息就不会收到。Server就因为接收不到Client的信息而无法正常关闭。
2. 防止“已失效的连接请求报文段”出现在本连接中。在发送完最后一个ACK报文段后,再经过2MSL,就可以使本连接持续的时间内所产生的所有报文段,都从网络中消失。这样就可以使下一个新的连接中不会出现这种就得连接请求报文段。

# # 参考资料

[TCP三次握手与四次挥手](http://www.cnblogs.com/wupeixuan/p/8639469.html)

[TCP 为什么是三次握手，而不是两次或四次？](https://www.zhihu.com/question/24853633/answer/573627478)

