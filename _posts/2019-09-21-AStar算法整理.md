---
layout:     post
title:     AStar算法整理
subtitle:   leetcode
date:       2019-09-21
author:     rosewind
header-img: img/animation/34.png
catalog: true
tags:
    - 算法
---

## A*算法原理

### 基本

- open list:待检查的节点列表，路径可能沿途经过，也可能不经过
- 由于会从open表中每次去f值最小的节点，常常用最小堆实现
- close list:已检查完毕的节点列表

### 流程

1. 起点加入open 表
2. 从open表中取出f值最小的节点A，将与A相邻并可达(即不是障碍)的节点加入open表,如果有已经在open表中的节点的话，判断哪个更优
3. A加入close 表
4. 重复2,3步直到到达终点

### 伪代码

```
while(OPEN!=NULL)
{
    从OPEN表中取f(n)最小的节点n;
    if(n节点==目标节点)
        break;
    for(当前节点n的每个子节点X)
    {
        计算f(X);
        if(XinOPEN)
            if(新的f(X)<OPEN中的f(X))
            {
                把n设置为X的父亲;
                更新OPEN表中的f(n);
            }
        if(XinCLOSE)
            continue;
        if(Xnotinboth)
        {
            把n设置为X的父亲;
            求f(X);
            并将X插入OPEN表中;//还没有排序
        }
    }//endfor
    将n节点插入CLOSE表中;
}
```

### tips

- open表往往用最小堆实现
- close表就是为了标识已检查完毕的节点，可以直接对每个节点加个标志位来区分

## 代码实现

```java
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;

public class Astar {
	private boolean[][] map;
	private int width;//宽
	private int height;//高
	public  List<Node> pathRes;
	public Astar(boolean[][] map) {
		// TODO Auto-generated constructor stub
		this.map = map;
		this.width = map[0].length;
		this.height = map.length;
	}
	/**
	 * 判断节点是否可达
	 * @param n
	 * @return
	 */
	private boolean isReachable(Node n){
		return map[n.getX()][n.getY()];
	}
	//判断坐标是否越界
	private boolean isValid(Node n){
		int x = n.getX();
		int y = n.getY();
		if(x < 0 || y <0 || x >= height || y>= width) return false;
		return true;
	}
	//获取一个点的所有的邻居,注意这个时候还为设置f
	private List<Node> getNeighb(Node n){
		List<Node> res = new ArrayList<Node>();
		//4个方向
		int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};
		for(int[] dir : dirs){
			Node newNode = new Node(n.getX() + dir[0],n.getY() + dir[1]);
			if(isValid(newNode) && isReachable(newNode)){
				res.add(newNode);
			}
		}
		return res;
	}
	public boolean findPath(Node start,Node end){
		//创建open表
		PriorityQueue<Node> openList = new PriorityQueue<Node>(11,new Comparator<Node>(){

			@Override
			public int compare(Node o1, Node o2) {
				// TODO Auto-generated method stub
				return (int) (o1.getF() - o2.getF());
			} 
		});
		//创建close list
		HashMap<Node,Integer> closeList = new HashMap<Node,Integer>();
		openList.add(start);
		while(!openList.isEmpty()){
			Node curNode = openList.poll();
			//找到了终点，直接返回
			if(curNode.equals(end)){
				calcPath(start, curNode);
				return true;
			}
			//所有邻居
			List<Node> neighbList = getNeighb(curNode);
			for(Node n : neighbList){
				//不在close中
				if(!closeList.containsKey(n)){
					//不在open中
					if(!openList.contains(n)){
						n.setParent(curNode);
						n.updateF(curNode.getG() + 1, end);
						openList.add(n);
					}
					else{
						double newF = curNode.getG() + 1 + DisHelper.calcManhaDis(n, end);
						if(newF < n.getF()){//更新父指针与f
							n.setParent(curNode);
							n.setF(newF);
							}
					}
				}
				//在close表中，跳过本次循环
			}
			//子节点处理完毕，当前节点加入close表
			closeList.put(curNode, 1);
		}
		return false;
	}
	
	private void calcPath(Node start,Node end){
		pathRes = new LinkedList<Node>();
		Node p = end;
		while(p.getParent() != null){
			//每次在头部插入，完成一个逆序的功能
			pathRes.add(0, p);
			p = p.getParent();
		}
	}
}
```

